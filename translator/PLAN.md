# Проект "Оркестратор Перевода"

## 1. Цель

Создать модульный, отказоустойчивый и расширяемый инструмент на Python для автоматизации и параллелизации процесса перевода больших текстовых глав. Инструмент будет использовать `gemini-cli` в качестве "воркеров" для выполнения задач перевода и анализа, управляя всем процессом из единой точки входа.

## 2. Структура Проекта

Проект будет иметь модульную структуру для удобства поддержки, отладки и дальнейшего расширения.

```
translator/
│
├── main.py                 # Главная точка входа. Парсит аргументы командной строки (путь к главе) и запускает оркестратор.
│
├── orchestrator.py         # "Мозг" проекта. Управляет всем процессом, запускает и контролирует воркеров.
│
├── task_manager.py         # Управляет жизненным циклом задач (создание, отслеживание, возобновление).
│
├── chapter_splitter.py     # Ваш скрипт, интегрированный как модуль. Отвечает за разделение глав на чанки.
│
├── term_collector.py       # Собирает и объединяет новые термины, найденные воркерами.
│
├── config.py               # Загружает и предоставляет доступ к конфигурации проекта.
│
├── config.json             # Файл конфигурации (пути, параметры чанкинга, настройки API).
│
└── prompts/                # Директория для хранения шаблонов промптов.
    ├── translation.txt     # Промпт для основного перевода.
    └── term_discovery.txt  # Промпт для поиска новых терминов.
```

## 3. Конфигурация (`config.json` и `prompts/`)

*   **`config.json`**: Центральный файл настроек. Будет содержать:
    *   Пути к рабочим директориям.
    *   Параметры для `chapter_splitter.py` (целевой размер чанка, максимальный размер).
    *   Настройки для `gemini-cli` (например, имя модели).
*   **`prompts/`**: Директория с текстовыми файлами промптов.
    *   **`translation.txt`**: Будет создан на основе лучших практик из изученного примера, включая "персону" и "синтаксический кодекс" для оформления диалогов.
    *   **`term_discovery.txt`**: Специализированный промпт, который дает AI задачу только найти новые термины и вернуть их в структурированном виде (например, JSON).

## 4. Основной Рабочий Процесс (`orchestrator.py`)

Процесс будет разделен на два обязательных этапа для обеспечения консистентности терминологии.

### Этап 1: Поиск Новых Терминов (Discovery Pass)

1.  **Запуск**: Пользователь запускает `main.py`, передавая путь к файлу главы.
2.  **Подготовка**: `orchestrator` вызывает функцию из нашего модуля `chapter_splitter` для нарезки главы на чанки. Затем `task_manager` создает структуру папок-очередей (`pending`, `in_progress`, `terms`, `done`, `failed`) в рабочей директории.
3.  **Параллельный Поиск**: Для каждого чанка в `pending`, `orchestrator` параллельно запускает процесс `gemini-cli` с помощью `subprocess.Popen`.
    *   **Команда**: `gemini-cli --prompt-file prompts/term_discovery.txt --input-file <путь_к_чанку> --output-file <путь_к_json_с_терминами> ...` (синтаксис требует уточнения).
4.  **Сбор и Утверждение**: После завершения всех процессов, `orchestrator` вызывает `term_collector` для сбора всех JSON-файлов с новыми терминами в единый список. Этот список выводится в консоль. Скрипт останавливается и ждет от пользователя подтверждения или правок.
5.  **Обновление Глоссария**: После подтверждения от пользователя, скрипт обновляет основной `data/glossary.json`.

### Этап 2: Перевод (Translation Pass)

1.  **Запуск**: Этот этап стартует автоматически после успешного завершения Этапа 1.
2.  **Параллельный Перевод**: Для каждого чанка в `pending`, `orchestrator` снова параллельно запускает `gemini-cli`.
    *   **Команда**: `gemini-cli --prompt-file prompts/translation.txt --glossary-file data/glossary.json --input-file <путь_к_чанку> --output-file <путь_к_переведенному_чанку> ...` (синтаксис требует уточнения).
3.  **Сборка**: После завершения всех процессов, `orchestrator` собирает все переведенные чанки из папки `done` в единый финальный файл `ru_draft.txt`, сохраняя их исходный порядок.
4.  **Завершение**: Скрипт сообщает об успешном завершении работы и пути к итоговому файлу.

## 5. Управление задачами и отказоустойчивость (`task_manager.py`)

Для надежности будет использоваться файловая система в качестве очереди.

*   **Структура**: Для каждой главы будет создаваться своя рабочая директория, например: `translator/workspace/chapter_2/`.
*   **Атомарность**: Перемещение файла чанка между папками (`pending` -> `in_progress` -> `done`/`failed`) является атомарной операцией. Это гарантирует, что даже при сбое скрипта мы всегда можем понять, какие задачи были в работе, и возобновить процесс.
*   **Логирование**: Каждый воркер (процесс `gemini-cli`) будет писать свой лог в отдельный файл, что упростит отладку.

## 6. Взаимодействие с `gemini-cli`

Исследование документации дало нам четкое понимание, как будет работать интеграция.

### 6.1. Принцип вызова

Мы будем использовать `gemini-cli` в "безголовом" (headless) режиме, передавая данные через стандартные потоки ввода/вывода (`stdin`, `stdout`) и промпт через аргумент командной строки.

### 6.2. Команда для Этапа 1 (Поиск терминов)

```bash
cat <путь_к_чанку> | gemini -p "<промпт_из_prompts/term_discovery.txt>" --output-format json > <путь_к_json_с_терминами>
```
*   **`cat <путь_к_чанку>`**: Содержимое чанка подается на `stdin`.
*   **`-p "..."`**: `orchestrator.py` будет программно формировать этот промпт, вставляя в него инструкции из `term_discovery.txt`.
*   **`--output-format json`**: Команда вернет JSON, из которого мы легко извлечем найденные термины.
*   **`> <путь_к_json_с_терминами>`**: Результат сохраняется в файл для последующего сбора.

### 6.3. Команда для Этапа 2 (Перевод)

```bash
cat <путь_к_чанку> | gemini -p "<финальный_промпт_с_глоссарием>" > <путь_к_переведенному_чанку>
```
*   **`-p "..."`**: `orchestrator.py` будет читать шаблон из `prompts/translation.txt`, загружать и фильтровать `data/glossary.json`, вставлять все это в шаблон и передавать как единую строку.
*   **`> <путь_к_переведенному_чанку>`**: Результат (переведенный HTML) сохраняется в файл.

### 6.4. Обработка ошибок

Мы будем полагаться на стандартное поведение CLI-инструментов:
*   **Код выхода (Exit Code)**: `subprocess.Popen` будет проверять код выхода. Ненулевой код будет означать ошибку, и `task_manager` переместит задачу в папку `failed`.
*   **`stderr`**: Мы будем захватывать и логировать поток `stderr` для каждой задачи, чтобы упростить отладку.

## 7. Поэтапный план реализации

1.  **Инициализация**: Создать структуру папок и пустые файлы `.py` согласно архитектуре.
2.  **Конфигурация**: Реализовать `config.py`. Создать `config.json` и базовые версии промптов в `prompts/`.
3.  **Реализация модулей**: Последовательно реализовать функционал в следующем порядке:
    1.  Адаптировать `chapter_splitter.py`, чтобы его можно было импортировать как модуль и вызывать из `orchestrator.py`.
    2.  `task_manager.py`
    3.  `term_collector.py`
    4.  `orchestrator.py` (ядро с `subprocess.Popen`)
    5.  `main.py` (обвязка для командной строки)
4.  **Тестирование и отладка**: Провести полное тестирование всего конвейера на реальных данных.
