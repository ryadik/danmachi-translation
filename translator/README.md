# Script-Orchestrator для перевода текстов

Этот проект представляет собой автоматизированный скрипт-оркестратор на Python, предназначенный для двухэтапного перевода больших текстовых файлов с использованием `gemini-cli`. Система спроектирована с упором на отказоустойчивость, параллелизацию и минимизацию повторных вызовов API.

### ВАЖНО
**Мне абсолютно не хотелось заморачиваться и писать воркеры на ноде, так что я _полностью навайбил_ (через Gemini 2.5 pro) скрипт на змее, поэтому какое качество кода, я без понятия. Заточен только под перевод данного тайтла.**

## Основные возможности

- **Интеллектуальное разделение глав**: Автоматически разбивает большие текстовые файлы на небольшие, семантически связанные части (чанки) для обработки.
- **Двухэтапный перевод**:
  1.  **Этап поиска терминов**: Параллельно обрабатывает все чанки для обнаружения новых, неизвестных терминов.
  2.  **Этап перевода**: После подтверждения терминов пользователем, параллельно переводит все чанки, используя обновленный глоссарий.
- **Параллельная обработка**: Запускает несколько процессов `gemini-cli` одновременно, чтобы значительно ускорить обработку. Количество параллельных воркеров настраивается, чтобы избежать превышения лимитов API (RPS).
- **Менеджмент задач на основе файловой системы**: Отслеживает состояние каждого чанка через систему папок (`pending`, `in_progress`, `done`, `failed`), что обеспечивает наглядность и отказоустойчивость.
- **Полная отказоустойчивость**:
  - **Блокировка (Locking)**: Предотвращает одновременный запуск двух процессов для одной и той же главы, избегая конфликтов.
  - **Чекпоинты (Checkpoints)**: Создает файлы-маркеры (`.stage_*_complete`) после успешного завершения каждого этапа. При перезапуске скрипт автоматически пропускает уже выполненные этапы.
  - **Возобновление (`--resume`)**: Позволяет безопасно возобновить прерванный процесс. Скрипт автоматически соберет "зависшие" и "упавшие" задачи и вернет их в очередь на обработку.

---

## Руководство пользователя

### 1. Предварительные требования

- **Python 3.x**.
- **`gemini-cli`**: Утилита должна быть установлена и авторизована. Выполните `gemini auth`, если вы этого еще не сделали.

### 2. Структура файлов

- `text/chapters/<имя_главы>/jp.txt`: Место для ваших исходных текстовых файлов. Скрипт использует имя родительской папки (`<имя_главы>`) для создания рабочей директории.
- `data/glossary.json`: Основной глоссарий проекта. Новые подтвержденные термины автоматически добавляются сюда.
- `translator/prompts/`: Папка с текстовыми файлами промптов для каждого этапа.
- `translator/config.json`: Главный файл конфигурации.
- `translator/workspace/`: Рабочая директория, где происходит вся "магия". Можно безопасно удалять содержимое для чистого старта.
- `<имя_главы>_translated.txt`: Готовый файл с переводом, который появляется в корневой директории проекта после успешного завершения.

### 3. Конфигурация (`translator/config.json`)

- `workspace_dir`: Путь к рабочей директории.
- `max_concurrent_workers`: **Важный параметр!** Количество одновременно запущенных процессов `gemini-cli`. Установите `2` или `3`, чтобы не превышать лимиты бесплатной версии API.
- `chapter_splitter`: Настройки для разделения глав.
  - `target_chunk_size`: Желаемый размер одного чанка в символах.

### 4. Как использовать

#### Стандартный запуск
Эта команда запускает полный процесс для указанной главы.

```bash
python3 translator/main.py text/chapters/prologue/jp.txt
```

#### Принудительный чистый запуск (`--force-split`)
Если вам нужно начать обработку главы с самого нуля, игнорируя все предыдущие результаты и чекпоинты, используйте этот флаг. Он полностью удалит рабочую директорию для данной главы перед запуском.

```bash
python3 translator/main.py --force-split text/chapters/prologue/jp.txt
```

#### Возобновление после сбоя (`--resume`)
Если процесс был прерван (из-за ошибки, отключения питания или вручную), используйте этот флаг. Скрипт подхватит работу с того места, где остановился: вернет в очередь зависшие задачи и пропустит уже завершенные этапы.

```bash
python3 translator/main.py --resume text/chapters/prologue/jp.txt
```

#### Запуск с последуюим созранением рабочей области (`--debug`)
Добавляет флаг `--debug`, который позволит сохранить рабочую директорию главы после **успешного** завершения всего процесса.

```bash
python3 translator/main.py --debug text/chapters/prologue/jp.txt
```

### 5. Рабочий процесс

1.  Поместите исходный файл в `text/chapters/prologue/jp.txt`.
2.  Запустите скрипт, используя одну из команд выше.
3.  Если скрипт найдет новые термины, он остановится и выведет их список в консоль, ожидая вашей команды.
    - `ok`: Принять все предложенные термины.
    - `del <индекс>`: Удалить термин.
    - `edit <индекс> <новый_перевод>`: Изменить перевод термина.
    - `quit`: Прервать процесс.
4.  Дождитесь завершения всех этапов.
5.  Готовый файл `prologue_translated.txt` появится в корневой папке проекта.

---

## Руководство для разработчиков

### Архитектура

Система построена на двух ключевых принципах:
1.  **Оркестратор и Воркеры**: `orchestrator.py` выступает в роли "мозга", который управляет логикой этапов. В качестве "воркеров" он порождает дочерние процессы `gemini-cli`.
2.  **Состояние в файловой системе**: Вместо сложной базы данных, состояние процесса хранится в файловой системе внутри папки `translator/workspace/`. Это делает процесс наглядным, легко отлаживаемым и по-настоящему отказоустойчивым.

### Компоненты системы

- `main.py`: Точка входа. Отвечает за парсинг аргументов командной строки (`argparse`) и вызов оркестратора.
- `orchestrator.py`: **Ядро системы.**
  - Управляет общей последовательностью выполнения: `Разделение` -> `Поиск терминов` -> `Перевод` -> `Сборка`.
  - Реализует логику блокировок (`.lock`) и чекпоинтов (`.stage_*_complete`).
  - Содержит функцию `_run_workers_pooled`, которая запускает и управляет пулом дочерних процессов.
- `task_manager.py`: Отвечает за все операции с файловой системой в `workspace`.
  - Создает структуру папок для новой главы.
  - Перемещает файлы-задачи между состояниями (`pending`, `in_progress`, `done`, `failed`).
  - Реализует логику возобновления, собирая задачи из `in_progress` и `failed`.
- `chapter_splitter.py`: "Умный" сплиттер. Делит текст не просто по количеству символов, а ищет подходящие разрывы (пустые строки, концы диалогов), чтобы чанки были более осмысленными.
- `term_collector.py`: Интерактивный модуль. Собирает JSON-файлы с терминами, найденными на первом этапе, и организует диалог с пользователем для их подтверждения, редактирования или удаления.
- `config.py`: Простая утилита для загрузки и валидации `config.json`.

### Жизненный цикл задачи (чанка)

1.  `chapter_splitter` создает `part_N.txt` в папке `pending`.
2.  `orchestrator` берет задачу из `pending` и перемещает ее в `in_progress`.
3.  `orchestrator` запускает для нее воркер `gemini-cli`.
4.  **В случае успеха**:
    - На этапе поиска терминов: `part_N.txt` перемещается в `done`, а результат работы (`part_N_terms.json`) сохраняется в `terms`.
    - На этапе перевода: `part_N.txt` удаляется, а результат (`part_N_translated.txt`) сохраняется в `done`.
5.  **В случае ошибки**: `part_N.txt` перемещается из `in_progress` в `failed`.

### Как добавить новый этап (например, "Вычитка")

1.  **TaskManager**: При необходимости, добавьте новую папку в `setup_task_workspace` в `task_manager.py`.
2.  **Orchestrator**: В `run_translation_process` в `orchestrator.py`:
    - Добавьте новую переменную для чекпоинта: `proofreading_checkpoint = os.path.join(workspace_paths["base"], ".stage_proofreading_complete")`.
    - Создайте новый блок: `if not os.path.exists(proofreading_checkpoint):`.
    - Внутри блока:
      - Вызовите `task_manager.requeue_completed_tasks(workspace_paths)`, чтобы вернуть переведенные чанки в очередь `pending`.
      - Подготовьте новый промпт для вычитки.
      - Вызовите `_run_workers_pooled` с этим промптом.
      - После успешного выполнения создайте файл чекпоинта: `with open(proofreading_checkpoint, 'w') ...`.
3.  **Промпт**: Создайте новый файл с промптом в `translator/prompts/`.
4.  **Сборка**: Убедитесь, что финальный этап сборки использует результаты вашего нового этапа.

## Идеи для транслятора:

- [x] отладка и доработка взаимодейтсвия с глоссарием
  - [x] избавления от дубликатов типа "Айз" и "Айз Валенштайн" (это один персонаж но записей две)
  - [x] чnо есть термин? ясно определить, что не надо выводить как термин.
- [x] добавить единый логгер
- [x] сделать удаление `workspace` поумолчанию и убрать флаг `--cleanup`
- [x] добавить флаг `--debug` для того, чтобы `workspace` не удалялась после завершения
- [x] организовать структуру логов для воркспейса
- [ ] класть переведенный тест рядом с японским, а не в корень.
- [x] флаги на рабочий процесс, для страта сразу с нужного жтапа
- [x] реализация работы из любого места
- [ ] yolo режим для глоссария и перевода
- [ ] этап вычитки